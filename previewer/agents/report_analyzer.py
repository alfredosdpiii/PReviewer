from typing import Dict, List, Any
import os
import openai
from .base import BaseAgent, AgentState, Message, MessageType
from ..utils.logging_utils import setup_logger

logger = setup_logger("report_analyzer")

class ReportAnalyzerState(AgentState):
    """State of the report analyzer."""
    reports: List[Dict[str, Any]] = []

    class Config:
        arbitrary_types_allowed = True

class ReportAnalyzer(BaseAgent):
    """Agent for analyzing and formatting review reports."""
    state: ReportAnalyzerState

    class Config:
        arbitrary_types_allowed = True
    
    def __init__(self):
        """Initialize report analyzer."""
        super().__init__()
        self.state = ReportAnalyzerState(agent_id='report_analyzer')
        logger.info("Initializing report analyzer")
        logger.info("Report analyzer initialized")
        openai_api_key = os.getenv("OPENAI_API_KEY")
        if not openai_api_key:
            logger.error("OPENAI_API_KEY not found in environment variables")
            raise ValueError("OPENAI_API_KEY not found in environment variables")
            
        openai.api_key = openai_api_key
    
    def process_message(self, message: Message) -> List[Message]:
        """Process incoming messages and generate reports."""
        if message.type == MessageType.REVIEW:
            file_path = message.content.get('file_path')
            review = message.content.get('review')
            pr_number = message.content.get('pr_number')
            
            if not file_path or not review:
                logger.error("Missing file path or review in message")
                return [self.create_message(
                    MessageType.ERROR,
                    {'error': 'Missing file path or review'},
                    'orchestrator'
                )]
            
            logger.info(f"Processing review for {file_path}")
            
            # Store review
            self.state.reports.append({
                'file_path': file_path,
                'review': review,
                'pr_number': pr_number
            })
            
            # Generate report
            report = self._generate_report(file_path, review)
            
            return [self.create_message(
                MessageType.REPORT,
                {
                    'file_path': file_path,
                    'report': report,
                    'pr_number': pr_number
                },
                'orchestrator'
            )]
        
        return [self.create_message(
            MessageType.ERROR,
            {'error': f'Unsupported message type: {message.type}'},
            'orchestrator'
        )]
    
    def _generate_report(self, file_path: str, review: Dict) -> str:
        """Generate a comprehensive report from individual file reviews."""
        logger.info(f"Starting report generation for {file_path}")
        
        # Format the review into a GitHub-friendly markdown comment
        report = "# PR Review Report\n\n"
        
        # Add file review
        report += self._collect_reviews()
        
        # Add summary
        report += "\n\n## Summary\n"
        report += "This review was automatically generated by the PR Reviewer bot. "
        report += "Please check each suggestion carefully and make changes as needed.\n\n"
        
        # Format for GitHub
        return self._format_github_comment(report)
    
    def _collect_reviews(self) -> str:
        """Collect all reviews into a single text."""
        logger.info("Collecting all reviews")
        reviews_text = []
        
        for review_data in self.state.reports:
            logger.info(f"Processing review for {review_data['file_path']}")
            review = review_data.get('review', {})
            
            # Extract review components
            general_review = review.get('review', '')
            violations = review.get('best_practices_violations', [])
            suggestions = review.get('suggestions', [])
            
            # Format the review
            file_review = [
                f"\n## Review for {review_data['file_path']}",
                "\n### General Review",
                general_review
            ]
            
            if violations:
                file_review.extend([
                    "\n### Best Practice Violations",
                    "- " + "\n- ".join(violations)
                ])
            
            if suggestions:
                file_review.extend([
                    "\n### Improvement Suggestions",
                    "- " + "\n- ".join(suggestions)
                ])
            
            reviews_text.append("\n".join(file_review))
        
        return "\n\n".join(reviews_text)
    
    def _format_github_comment(self, summary: str) -> str:
        """Format the summary as a GitHub comment."""
        logger.info("Formatting report as GitHub comment")
        return f"""# Pull Request Review Summary

{summary}

---
*This review was automatically generated by PReviewer ðŸ¤–*
"""
